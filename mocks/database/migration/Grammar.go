// Code generated by mockery. DO NOT EDIT.

package migration

import (
	migration "github.com/goravel/framework/contracts/database/migration"
	mock "github.com/stretchr/testify/mock"

	orm "github.com/goravel/framework/contracts/database/orm"
)

// Grammar is an autogenerated mock type for the Grammar type
type Grammar struct {
	mock.Mock
}

type Grammar_Expecter struct {
	mock *mock.Mock
}

func (_m *Grammar) EXPECT() *Grammar_Expecter {
	return &Grammar_Expecter{mock: &_m.Mock}
}

// CompileCreate provides a mock function with given fields: blueprint, query
func (_m *Grammar) CompileCreate(blueprint migration.Blueprint, query orm.Query) string {
	ret := _m.Called(blueprint, query)

	if len(ret) == 0 {
		panic("no return value specified for CompileCreate")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(migration.Blueprint, orm.Query) string); ok {
		r0 = rf(blueprint, query)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileCreate'
type Grammar_CompileCreate_Call struct {
	*mock.Call
}

// CompileCreate is a helper method to define mock.On call
//   - blueprint migration.Blueprint
//   - query orm.Query
func (_e *Grammar_Expecter) CompileCreate(blueprint interface{}, query interface{}) *Grammar_CompileCreate_Call {
	return &Grammar_CompileCreate_Call{Call: _e.mock.On("CompileCreate", blueprint, query)}
}

func (_c *Grammar_CompileCreate_Call) Run(run func(blueprint migration.Blueprint, query orm.Query)) *Grammar_CompileCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(migration.Blueprint), args[1].(orm.Query))
	})
	return _c
}

func (_c *Grammar_CompileCreate_Call) Return(_a0 string) *Grammar_CompileCreate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileCreate_Call) RunAndReturn(run func(migration.Blueprint, orm.Query) string) *Grammar_CompileCreate_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDropIfExists provides a mock function with given fields: blueprint
func (_m *Grammar) CompileDropIfExists(blueprint migration.Blueprint) string {
	ret := _m.Called(blueprint)

	if len(ret) == 0 {
		panic("no return value specified for CompileDropIfExists")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(migration.Blueprint) string); ok {
		r0 = rf(blueprint)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileDropIfExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDropIfExists'
type Grammar_CompileDropIfExists_Call struct {
	*mock.Call
}

// CompileDropIfExists is a helper method to define mock.On call
//   - blueprint migration.Blueprint
func (_e *Grammar_Expecter) CompileDropIfExists(blueprint interface{}) *Grammar_CompileDropIfExists_Call {
	return &Grammar_CompileDropIfExists_Call{Call: _e.mock.On("CompileDropIfExists", blueprint)}
}

func (_c *Grammar_CompileDropIfExists_Call) Run(run func(blueprint migration.Blueprint)) *Grammar_CompileDropIfExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(migration.Blueprint))
	})
	return _c
}

func (_c *Grammar_CompileDropIfExists_Call) Return(_a0 string) *Grammar_CompileDropIfExists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDropIfExists_Call) RunAndReturn(run func(migration.Blueprint) string) *Grammar_CompileDropIfExists_Call {
	_c.Call.Return(run)
	return _c
}

// CompileTables provides a mock function with given fields: database
func (_m *Grammar) CompileTables(database string) string {
	ret := _m.Called(database)

	if len(ret) == 0 {
		panic("no return value specified for CompileTables")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(database)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileTables_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileTables'
type Grammar_CompileTables_Call struct {
	*mock.Call
}

// CompileTables is a helper method to define mock.On call
//   - database string
func (_e *Grammar_Expecter) CompileTables(database interface{}) *Grammar_CompileTables_Call {
	return &Grammar_CompileTables_Call{Call: _e.mock.On("CompileTables", database)}
}

func (_c *Grammar_CompileTables_Call) Run(run func(database string)) *Grammar_CompileTables_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Grammar_CompileTables_Call) Return(_a0 string) *Grammar_CompileTables_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileTables_Call) RunAndReturn(run func(string) string) *Grammar_CompileTables_Call {
	_c.Call.Return(run)
	return _c
}

// GetAttributeCommands provides a mock function with given fields:
func (_m *Grammar) GetAttributeCommands() []string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAttributeCommands")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// Grammar_GetAttributeCommands_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAttributeCommands'
type Grammar_GetAttributeCommands_Call struct {
	*mock.Call
}

// GetAttributeCommands is a helper method to define mock.On call
func (_e *Grammar_Expecter) GetAttributeCommands() *Grammar_GetAttributeCommands_Call {
	return &Grammar_GetAttributeCommands_Call{Call: _e.mock.On("GetAttributeCommands")}
}

func (_c *Grammar_GetAttributeCommands_Call) Run(run func()) *Grammar_GetAttributeCommands_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Grammar_GetAttributeCommands_Call) Return(_a0 []string) *Grammar_GetAttributeCommands_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_GetAttributeCommands_Call) RunAndReturn(run func() []string) *Grammar_GetAttributeCommands_Call {
	_c.Call.Return(run)
	return _c
}

// GetModifiers provides a mock function with given fields:
func (_m *Grammar) GetModifiers() []func(migration.Blueprint, migration.ColumnDefinition) string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetModifiers")
	}

	var r0 []func(migration.Blueprint, migration.ColumnDefinition) string
	if rf, ok := ret.Get(0).(func() []func(migration.Blueprint, migration.ColumnDefinition) string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]func(migration.Blueprint, migration.ColumnDefinition) string)
		}
	}

	return r0
}

// Grammar_GetModifiers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetModifiers'
type Grammar_GetModifiers_Call struct {
	*mock.Call
}

// GetModifiers is a helper method to define mock.On call
func (_e *Grammar_Expecter) GetModifiers() *Grammar_GetModifiers_Call {
	return &Grammar_GetModifiers_Call{Call: _e.mock.On("GetModifiers")}
}

func (_c *Grammar_GetModifiers_Call) Run(run func()) *Grammar_GetModifiers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Grammar_GetModifiers_Call) Return(_a0 []func(migration.Blueprint, migration.ColumnDefinition) string) *Grammar_GetModifiers_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_GetModifiers_Call) RunAndReturn(run func() []func(migration.Blueprint, migration.ColumnDefinition) string) *Grammar_GetModifiers_Call {
	_c.Call.Return(run)
	return _c
}

// TypeBigInteger provides a mock function with given fields: column
func (_m *Grammar) TypeBigInteger(column migration.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeBigInteger")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(migration.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeBigInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeBigInteger'
type Grammar_TypeBigInteger_Call struct {
	*mock.Call
}

// TypeBigInteger is a helper method to define mock.On call
//   - column migration.ColumnDefinition
func (_e *Grammar_Expecter) TypeBigInteger(column interface{}) *Grammar_TypeBigInteger_Call {
	return &Grammar_TypeBigInteger_Call{Call: _e.mock.On("TypeBigInteger", column)}
}

func (_c *Grammar_TypeBigInteger_Call) Run(run func(column migration.ColumnDefinition)) *Grammar_TypeBigInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(migration.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeBigInteger_Call) Return(_a0 string) *Grammar_TypeBigInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeBigInteger_Call) RunAndReturn(run func(migration.ColumnDefinition) string) *Grammar_TypeBigInteger_Call {
	_c.Call.Return(run)
	return _c
}

// TypeInteger provides a mock function with given fields: column
func (_m *Grammar) TypeInteger(column migration.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeInteger")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(migration.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeInteger'
type Grammar_TypeInteger_Call struct {
	*mock.Call
}

// TypeInteger is a helper method to define mock.On call
//   - column migration.ColumnDefinition
func (_e *Grammar_Expecter) TypeInteger(column interface{}) *Grammar_TypeInteger_Call {
	return &Grammar_TypeInteger_Call{Call: _e.mock.On("TypeInteger", column)}
}

func (_c *Grammar_TypeInteger_Call) Run(run func(column migration.ColumnDefinition)) *Grammar_TypeInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(migration.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeInteger_Call) Return(_a0 string) *Grammar_TypeInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeInteger_Call) RunAndReturn(run func(migration.ColumnDefinition) string) *Grammar_TypeInteger_Call {
	_c.Call.Return(run)
	return _c
}

// TypeString provides a mock function with given fields: column
func (_m *Grammar) TypeString(column migration.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeString")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(migration.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeString'
type Grammar_TypeString_Call struct {
	*mock.Call
}

// TypeString is a helper method to define mock.On call
//   - column migration.ColumnDefinition
func (_e *Grammar_Expecter) TypeString(column interface{}) *Grammar_TypeString_Call {
	return &Grammar_TypeString_Call{Call: _e.mock.On("TypeString", column)}
}

func (_c *Grammar_TypeString_Call) Run(run func(column migration.ColumnDefinition)) *Grammar_TypeString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(migration.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeString_Call) Return(_a0 string) *Grammar_TypeString_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeString_Call) RunAndReturn(run func(migration.ColumnDefinition) string) *Grammar_TypeString_Call {
	_c.Call.Return(run)
	return _c
}

// NewGrammar creates a new instance of Grammar. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGrammar(t interface {
	mock.TestingT
	Cleanup(func())
}) *Grammar {
	mock := &Grammar{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
