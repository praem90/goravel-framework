// Code generated by mockery. DO NOT EDIT.

package migration

import (
	migration "github.com/goravel/framework/contracts/database/migration"
	mock "github.com/stretchr/testify/mock"

	orm "github.com/goravel/framework/contracts/database/orm"
)

// Blueprint is an autogenerated mock type for the Blueprint type
type Blueprint struct {
	mock.Mock
}

type Blueprint_Expecter struct {
	mock *mock.Mock
}

func (_m *Blueprint) EXPECT() *Blueprint_Expecter {
	return &Blueprint_Expecter{mock: &_m.Mock}
}

// Build provides a mock function with given fields: query, grammar
func (_m *Blueprint) Build(query orm.Query, grammar migration.Grammar) error {
	ret := _m.Called(query, grammar)

	if len(ret) == 0 {
		panic("no return value specified for Build")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(orm.Query, migration.Grammar) error); ok {
		r0 = rf(query, grammar)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Blueprint_Build_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Build'
type Blueprint_Build_Call struct {
	*mock.Call
}

// Build is a helper method to define mock.On call
//   - query orm.Query
//   - grammar migration.Grammar
func (_e *Blueprint_Expecter) Build(query interface{}, grammar interface{}) *Blueprint_Build_Call {
	return &Blueprint_Build_Call{Call: _e.mock.On("Build", query, grammar)}
}

func (_c *Blueprint_Build_Call) Run(run func(query orm.Query, grammar migration.Grammar)) *Blueprint_Build_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(orm.Query), args[1].(migration.Grammar))
	})
	return _c
}

func (_c *Blueprint_Build_Call) Return(_a0 error) *Blueprint_Build_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Build_Call) RunAndReturn(run func(orm.Query, migration.Grammar) error) *Blueprint_Build_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function with given fields:
func (_m *Blueprint) Create() {
	_m.Called()
}

// Blueprint_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type Blueprint_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
func (_e *Blueprint_Expecter) Create() *Blueprint_Create_Call {
	return &Blueprint_Create_Call{Call: _e.mock.On("Create")}
}

func (_c *Blueprint_Create_Call) Run(run func()) *Blueprint_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_Create_Call) Return() *Blueprint_Create_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_Create_Call) RunAndReturn(run func()) *Blueprint_Create_Call {
	_c.Call.Return(run)
	return _c
}

// DropIfExists provides a mock function with given fields:
func (_m *Blueprint) DropIfExists() {
	_m.Called()
}

// Blueprint_DropIfExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropIfExists'
type Blueprint_DropIfExists_Call struct {
	*mock.Call
}

// DropIfExists is a helper method to define mock.On call
func (_e *Blueprint_Expecter) DropIfExists() *Blueprint_DropIfExists_Call {
	return &Blueprint_DropIfExists_Call{Call: _e.mock.On("DropIfExists")}
}

func (_c *Blueprint_DropIfExists_Call) Run(run func()) *Blueprint_DropIfExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_DropIfExists_Call) Return() *Blueprint_DropIfExists_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropIfExists_Call) RunAndReturn(run func()) *Blueprint_DropIfExists_Call {
	_c.Call.Return(run)
	return _c
}

// GetAddedColumns provides a mock function with given fields:
func (_m *Blueprint) GetAddedColumns() []migration.ColumnDefinition {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAddedColumns")
	}

	var r0 []migration.ColumnDefinition
	if rf, ok := ret.Get(0).(func() []migration.ColumnDefinition); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]migration.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_GetAddedColumns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAddedColumns'
type Blueprint_GetAddedColumns_Call struct {
	*mock.Call
}

// GetAddedColumns is a helper method to define mock.On call
func (_e *Blueprint_Expecter) GetAddedColumns() *Blueprint_GetAddedColumns_Call {
	return &Blueprint_GetAddedColumns_Call{Call: _e.mock.On("GetAddedColumns")}
}

func (_c *Blueprint_GetAddedColumns_Call) Run(run func()) *Blueprint_GetAddedColumns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_GetAddedColumns_Call) Return(_a0 []migration.ColumnDefinition) *Blueprint_GetAddedColumns_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_GetAddedColumns_Call) RunAndReturn(run func() []migration.ColumnDefinition) *Blueprint_GetAddedColumns_Call {
	_c.Call.Return(run)
	return _c
}

// GetChangedColumns provides a mock function with given fields:
func (_m *Blueprint) GetChangedColumns() []migration.ColumnDefinition {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetChangedColumns")
	}

	var r0 []migration.ColumnDefinition
	if rf, ok := ret.Get(0).(func() []migration.ColumnDefinition); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]migration.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_GetChangedColumns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetChangedColumns'
type Blueprint_GetChangedColumns_Call struct {
	*mock.Call
}

// GetChangedColumns is a helper method to define mock.On call
func (_e *Blueprint_Expecter) GetChangedColumns() *Blueprint_GetChangedColumns_Call {
	return &Blueprint_GetChangedColumns_Call{Call: _e.mock.On("GetChangedColumns")}
}

func (_c *Blueprint_GetChangedColumns_Call) Run(run func()) *Blueprint_GetChangedColumns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_GetChangedColumns_Call) Return(_a0 []migration.ColumnDefinition) *Blueprint_GetChangedColumns_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_GetChangedColumns_Call) RunAndReturn(run func() []migration.ColumnDefinition) *Blueprint_GetChangedColumns_Call {
	_c.Call.Return(run)
	return _c
}

// GetTableName provides a mock function with given fields:
func (_m *Blueprint) GetTableName() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetTableName")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Blueprint_GetTableName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTableName'
type Blueprint_GetTableName_Call struct {
	*mock.Call
}

// GetTableName is a helper method to define mock.On call
func (_e *Blueprint_Expecter) GetTableName() *Blueprint_GetTableName_Call {
	return &Blueprint_GetTableName_Call{Call: _e.mock.On("GetTableName")}
}

func (_c *Blueprint_GetTableName_Call) Run(run func()) *Blueprint_GetTableName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_GetTableName_Call) Return(_a0 string) *Blueprint_GetTableName_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_GetTableName_Call) RunAndReturn(run func() string) *Blueprint_GetTableName_Call {
	_c.Call.Return(run)
	return _c
}

// HasCommand provides a mock function with given fields: command
func (_m *Blueprint) HasCommand(command string) bool {
	ret := _m.Called(command)

	if len(ret) == 0 {
		panic("no return value specified for HasCommand")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(command)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Blueprint_HasCommand_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasCommand'
type Blueprint_HasCommand_Call struct {
	*mock.Call
}

// HasCommand is a helper method to define mock.On call
//   - command string
func (_e *Blueprint_Expecter) HasCommand(command interface{}) *Blueprint_HasCommand_Call {
	return &Blueprint_HasCommand_Call{Call: _e.mock.On("HasCommand", command)}
}

func (_c *Blueprint_HasCommand_Call) Run(run func(command string)) *Blueprint_HasCommand_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_HasCommand_Call) Return(_a0 bool) *Blueprint_HasCommand_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_HasCommand_Call) RunAndReturn(run func(string) bool) *Blueprint_HasCommand_Call {
	_c.Call.Return(run)
	return _c
}

// ID provides a mock function with given fields: column
func (_m *Blueprint) ID(column ...string) migration.ColumnDefinition {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ID")
	}

	var r0 migration.ColumnDefinition
	if rf, ok := ret.Get(0).(func(...string) migration.ColumnDefinition); ok {
		r0 = rf(column...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(migration.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_ID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ID'
type Blueprint_ID_Call struct {
	*mock.Call
}

// ID is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) ID(column ...interface{}) *Blueprint_ID_Call {
	return &Blueprint_ID_Call{Call: _e.mock.On("ID",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_ID_Call) Run(run func(column ...string)) *Blueprint_ID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_ID_Call) Return(_a0 migration.ColumnDefinition) *Blueprint_ID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_ID_Call) RunAndReturn(run func(...string) migration.ColumnDefinition) *Blueprint_ID_Call {
	_c.Call.Return(run)
	return _c
}

// Integer provides a mock function with given fields: column
func (_m *Blueprint) Integer(column string) migration.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Integer")
	}

	var r0 migration.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) migration.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(migration.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Integer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Integer'
type Blueprint_Integer_Call struct {
	*mock.Call
}

// Integer is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Integer(column interface{}) *Blueprint_Integer_Call {
	return &Blueprint_Integer_Call{Call: _e.mock.On("Integer", column)}
}

func (_c *Blueprint_Integer_Call) Run(run func(column string)) *Blueprint_Integer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Integer_Call) Return(_a0 migration.ColumnDefinition) *Blueprint_Integer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Integer_Call) RunAndReturn(run func(string) migration.ColumnDefinition) *Blueprint_Integer_Call {
	_c.Call.Return(run)
	return _c
}

// SetTable provides a mock function with given fields: name
func (_m *Blueprint) SetTable(name string) {
	_m.Called(name)
}

// Blueprint_SetTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetTable'
type Blueprint_SetTable_Call struct {
	*mock.Call
}

// SetTable is a helper method to define mock.On call
//   - name string
func (_e *Blueprint_Expecter) SetTable(name interface{}) *Blueprint_SetTable_Call {
	return &Blueprint_SetTable_Call{Call: _e.mock.On("SetTable", name)}
}

func (_c *Blueprint_SetTable_Call) Run(run func(name string)) *Blueprint_SetTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_SetTable_Call) Return() *Blueprint_SetTable_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_SetTable_Call) RunAndReturn(run func(string)) *Blueprint_SetTable_Call {
	_c.Call.Return(run)
	return _c
}

// String provides a mock function with given fields: column, length
func (_m *Blueprint) String(column string, length ...int) migration.ColumnDefinition {
	_va := make([]interface{}, len(length))
	for _i := range length {
		_va[_i] = length[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for String")
	}

	var r0 migration.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) migration.ColumnDefinition); ok {
		r0 = rf(column, length...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(migration.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_String_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'String'
type Blueprint_String_Call struct {
	*mock.Call
}

// String is a helper method to define mock.On call
//   - column string
//   - length ...int
func (_e *Blueprint_Expecter) String(column interface{}, length ...interface{}) *Blueprint_String_Call {
	return &Blueprint_String_Call{Call: _e.mock.On("String",
		append([]interface{}{column}, length...)...)}
}

func (_c *Blueprint_String_Call) Run(run func(column string, length ...int)) *Blueprint_String_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_String_Call) Return(_a0 migration.ColumnDefinition) *Blueprint_String_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_String_Call) RunAndReturn(run func(string, ...int) migration.ColumnDefinition) *Blueprint_String_Call {
	_c.Call.Return(run)
	return _c
}

// ToSql provides a mock function with given fields: query, grammar
func (_m *Blueprint) ToSql(query orm.Query, grammar migration.Grammar) []string {
	ret := _m.Called(query, grammar)

	if len(ret) == 0 {
		panic("no return value specified for ToSql")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func(orm.Query, migration.Grammar) []string); ok {
		r0 = rf(query, grammar)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// Blueprint_ToSql_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ToSql'
type Blueprint_ToSql_Call struct {
	*mock.Call
}

// ToSql is a helper method to define mock.On call
//   - query orm.Query
//   - grammar migration.Grammar
func (_e *Blueprint_Expecter) ToSql(query interface{}, grammar interface{}) *Blueprint_ToSql_Call {
	return &Blueprint_ToSql_Call{Call: _e.mock.On("ToSql", query, grammar)}
}

func (_c *Blueprint_ToSql_Call) Run(run func(query orm.Query, grammar migration.Grammar)) *Blueprint_ToSql_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(orm.Query), args[1].(migration.Grammar))
	})
	return _c
}

func (_c *Blueprint_ToSql_Call) Return(_a0 []string) *Blueprint_ToSql_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_ToSql_Call) RunAndReturn(run func(orm.Query, migration.Grammar) []string) *Blueprint_ToSql_Call {
	_c.Call.Return(run)
	return _c
}

// NewBlueprint creates a new instance of Blueprint. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBlueprint(t interface {
	mock.TestingT
	Cleanup(func())
}) *Blueprint {
	mock := &Blueprint{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
